请求和响应都经过 过滤 这里的意思就是chain这个代码在在doFilter中是一个跳转继续执行程序的方法 按照顺序结构...执行而已
点击登录，然后会走过滤器，还没登录成功所以session没有用户信息，所以会循环如果登录拦截
搞清楚放行的意思，你点退出之后会被拦截，不放行退出的话，等于说你点退出会重定向到index.jsp  假退出
过滤器还可以继续完善，这里程序登录后可以访问所有JSP，后序还需要对各个JSP触发条件进行过滤


Filter过滤器:

当前项目存在的问题是 可以直接url .jsp文件（登入情况下||未登入情况下） 判断是否登入情况 等代码冗余 如果有多个业务就需要每个业务写一个判断是否登入的代码
这里就可以设置一个过滤器(Servlet规范中的过滤器)放行指定情况下可以通过的url请求，可以继续执行servlet(jsp本质也是servlet)，同样也解决了重复代码的冗余性

Filter是什么？ 有什么用？
    Filter是过滤器
    Filter可以在Servlet这个目标程序执行之前添加代码，也可以在Servlet执行之后添加代码 ，也就是创建放行拦截条件 之类的吧  设定过滤规则 也就是这个意思
    一把情况下 都是在过滤器中编写公共代码

一个过滤器应该怎么写:
    第一步: 编写一个java类实现jarkata.servlet.Filter 并且实现这个接口中的所有方法  但是这个接口里面有default方法有函数体(但也是接口) 可以只实现没default的方法(实现完非抽象类)
        init()方法   在Filter对象创建的时候调用一次
        doFilter()方法   用户发送一次请求调用一次
        destory()方法  在Filter对象销毁的时候调用一次
    Filter对象的声明周期和Serlvet对象的区别: 在服务器启动的时候Filter对象自动创建  Servlet对象的创建是在第一次请求此路径时  服务器关闭时都销毁
    Filter对象的优先级 高于 Servlet对象的优先级
    第二步: 配置web.xml 文件中的路径 对应Filter  也可以用注解

    目标servlet执行条件
        过滤器中有chain.doFilter(....)方法
        servlet路径对应Filte的请求路径
    想要执行目标servlet就一定要执行filterChain 这也是后来代码中放行拦截servlet的核心方法
    执行下一个 Filter 如果没有下一个Filter就直接执行 请求路径对应的Servlet方法
    关于Filter的配置路径:
        精准路径匹配
        *.jsp 后缀匹配路径匹配
        /mirror/* 前缀路径匹配
        /* 全部路径

    有多个过滤器时的执行顺序:
        如果Filter的请求路径在web.xml中则按照上下顺序
        如果Filter的请求路径在注解中按照字典序

    过滤器的调用顺序 遵顼栈的数据结构

过滤器中的设计模式:
    责任链设计模式
    过滤器最大的有点:
        在web.xml中配置请求路径信息的好处  程序编译阶段不会确定调用顺序  修改xml就可以改变顺序
    责任链设计模式最大核心思想:
        在程序的运行阶段 动态的组合程序的调用顺序

