对代理模式的理解
理解：
比如拍电影的时候演员找替身
找替身的原因：
原因一: 保护自身安全 （保护自己）
原因二: 让替身完成一些高难度的动作 （增强功能）
原因三:

在java程序中应用代理模式的作用:
第一个作用: 保护自身对象
第二个作用: 增强当前方法的功能
第三个作用: A对象无法和B对象直接交互的时候可以通过代理模式来解决

代理模式中的三大角色
第一个角色: 目标对象
第二个角色: 代理对象
第三个角色: 目标对象和代理兑现的共同接口

为什么演员和替身演员要有相同的行为动作呢？
如果你使用代理模式的话，对于客户端程序来说，客户端是无法察觉到的，客户端在这里的观众其实就是“客户端程序”。
使用代理对象的时候就像在使用目标对象。是因为不想让观众知道是替身演员。


生活场景1：牛村的牛二看上了隔壁村小花，牛二不好意思直接找小花，于是牛二找来了媒婆王妈妈。
这里面就有一个非常典型的代理模式。
牛二不能和小花直接对接，只能找一个中间人。
其中王妈妈是代理类，牛二是目标类。王妈妈代替牛二和小花先见个面。（
现实生活中的婚介所）【在程序中，对象A和对象B无法直接交互时。】


生活场景2：你刚到北京，要租房子，可以自己找，也可以找链家帮你找。
其中链家是代理类，你是目标类。
你们两个都有共同的行为：找房子。不过链家除了满足你找房子，另外会收取一些费用的。
(现实生活中的房产中介)【在程序中，功能需要增强时。】


西游记场景：八戒和高小姐的故事。八戒要强抢民女高翠兰。
悟空得知此事之后怎么做的？悟空幻化成高小姐的模样。
代替高小姐与八戒会面。其中八戒是客户端程序。悟空是代理类。高小姐是目标类。
那天夜里，在八戒眼里，眼前的就是高小姐，对于八戒来说，他是不知道眼前的高小姐是悟空幻化的，在他内心里这就是高小姐。所以悟空代替高小姐和八戒亲了嘴儿。这是非常典型的代理模式实现的保护机制。
代理模式中有一个非常重要的特点：对于客户端程序来说，使用代理对象时就像在使用目标对象一样。【在程序中，目标需要被保护时】


业务场景：系统中有A、B、C三个模块，
使用这些模块的前提是需要用户登录，
也就是说在A模块中要编写判断登录的代码，B模块中也要编写，C模块中还要编写，
这些判断登录的代码反复出现，显然代码没有得到复用，可以为A、B、C三个模块提供一个代理，
在代理当中写一次登录判断即可。
代理的逻辑是：请求来了之后，判断用户是否登录了，如果已经登录了，
则执行对应的目标，如果没有登录则跳转到登录页面。【在程序中，目标不但受到保护，并且代码也得到了复用。】


代理模式是GoF23种设计模式之一。属于结构型设计模式。


代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问。
在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。
代理对象可以在客户端和目标对象之间起到中介的作用，
并且可以通过代理对象去掉客户不应该看到的内容和服务或者添加客户需要的额外服务。
通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，
这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。


代理模式中的角色：
● 代理类（代理主题）
● 目标类（真实主题）
● 代理类和目标类的公共接口（抽象主题）：客户端在使用代理类时就像在使用目标类，不被客户端所察觉，所以代理类和目标类要有共同的行为，也就是实现共同的接口。


代理模式在代码实现上，包括两种形式：
● 静态代理
● 动态代理

静态代理
看类例子
//项目已上线，并且运行正常，只是客户反馈系统有一些地方运行较慢，要求项目组对系统进行优化。
//于是项目负责人就下达了这个需求。首先需要搞清楚是哪些业务方法耗时较长，于是让我们统计每个业务方法所耗费的时长。
//如果是你，你该怎么做呢？
//第一种方案：直接修改Java源代码，在每个业务方法中添加统计逻辑
//需求可以满足，但显然是违背了OCP开闭原则。这种方案不可取。
//第二种方案：编写一个子类继承OrderServiceImpl，在子类中重写每个方法
//这种方式可以解决，但是存在两个问题：
//● 第一个问题：假设系统中有100个这样的业务类，需要提供100个子类，并且之前写好的创建Service对象的代码，都要修改为创建子类对象。
//● 第二个问题：由于采用了继承的方式，导致代码之间的耦合度较高。
//这种方案也不可取。
//第三种方案：使用代理模式（这里采用静态代理）
//可以为OrderService接口提供一个代理类
//以上就是代理模式中的静态代理，其中OrderService接口是代理类和目标类的共同接口。OrderServiceImpl是目标类。OrderServiceProxy是代理类。
//这种方式的优点：符合OCP开闭原则，同时采用的是关联关系，所以程序的耦合度较低。所以这种方案是被推荐的。
//大家思考一下：如果系统中业务接口很多，一个接口对应一个代理类，
// 显然也是不合理的，会导致类爆炸。
// 怎么解决这个问题？动态代理可以解决。
// 因为在动态代理中可以在内存中动态的为我们生成代理类的字节码。
// 代理类不需要我们写了。类爆炸解决了，而且代码只需要写一次，代码也会得到复用。

继承的耦合度比实现接口要高


类和类之间的关系:包括6种关系。
其中有两个关系是:
泛化关系
关联关系

泛化关系:继承
相比来说:泛化关系的耦合度高于关联关系。优先选择使用关联关系。


动态代理
在程序运行阶段，在内存中动态生成代理类，被称为动态代理，目的是为了减少代理类的数量。解决代码复用的问题
在内存当中动态生成类的技术常见的包括：
● JDK动态代理技术：只能代理接口。
● CGLIB动态代理技术：CGLIB(Code Generation Library)是一个开源项目。
  是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。
  它既可以代理接口，又可以代理类，底层是通过继承的方式实现的。
  性能比JDK动态代理要好。（底层有一个小而快的字节码处理框架ASM。）
● Javassist动态代理技术：Javassist是一个开源的分析、编辑和创建Java字节码的类库。
  是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。
  它已加入了开放源代码JBoss 应用服务器项目，通过使用Javassist对字节码操作为JBoss实现动态"AOP"框架。

JDK动态代理
我们还是使用静态代理中的例子：一个接口和一个实现类
// 第一步：创建目标对象
        OrderService target = new OrderServiceImpl();
        // 第二步：创建代理对象
        OrderService orderServiceProxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), 调用处理器对象);
        // 第三步：调用代理对象的代理方法
        orderServiceProxy.detail();
        orderServiceProxy.modify();
        orderServiceProxy.generate();

        以上第二步创建代理对象是需要大家理解的：
        OrderService orderServiceProxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), 调用处理器对象);
        这行代码做了两件事：
        ● 第一件事：在内存中生成了代理类的字节码
        ● 第二件事：创建代理对象
        Proxy类全名：java.lang.reflect.Proxy。这是JDK提供的一个类（所以称为JDK动态代理）。主要是通过这个类在内存中生成代理类的字节码。
        其中newProxyInstance()方法有三个参数：
        ● 第一个参数：类加载器。在内存中生成了字节码，要想执行这个字节码，也是需要先把这个字节码加载到内存当中的。所以要指定使用哪个类加载器加载。
        ● 第二个参数：接口类型。代理类和目标类实现相同的接口，所以要通过这个参数告诉JDK动态代理生成的类要实现哪些接口。
        ● 第三个参数：调用处理器。这是一个JDK动态代理规定的接口，接口全名：java.lang.reflect.InvocationHandler。显然这是一个回调接口，也就是说调用这个接口中方法的程序已经写好了，就差这个接口的实现类了。
        所以接下来我们要写一下java.lang.reflect.InvocationHandler接口的实现类，并且实现接口中的方法

        public class TimerInvocationHandler implements InvocationHandler {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                return null;
            }
        }

        InvocationHandler接口中有一个方法invoke，这个invoke方法上有三个参数：
        ● 第一个参数：Object proxy。代理对象。设计这个参数只是为了后期的方便，如果想在invoke方法中使用代理对象的话，尽管通过这个参数来使用。
        ● 第二个参数：Method method。目标方法。
        ● 第三个参数：Object[] args。目标方法调用时要传的参数。
        我们将来肯定是要调用“目标方法”的，但要调用目标方法的话，需要“目标对象”的存在，“目标对象”从哪儿来呢？我们可以给TimerInvocationHandler提供一个构造方法，可以通过这个构造方法传过来“目标对象”


        大家可能会比较好奇：那个InvocationHandler接口中的invoke()方法没看见在哪里调用呀？
        注意：当你调用代理对象的代理方法的时候，注册在InvocationHandler接口中的invoke()方法会被调用。也就是上面代码第24 25 26行，这三行代码中任意一行代码执行，注册在InvocationHandler接口中的invoke()方法都会被调用。

        学到这里可能会感觉有点懵，折腾半天，到最后这不是还得写一个接口的实现类吗？没省劲儿呀？
        你要这样想就错了!!!!
        我们可以看到，不管你有多少个Service接口，多少个业务类，这个TimerInvocationHandler接口是不是只需要写一次就行了，代码是不是得到复用了！！！！
        而且最重要的是，以后程序员只需要关注核心业务的编写了，像这种统计时间的代码根本不需要关注。因为这种统计时间的代码只需要在调用处理器中编写一次即可。
        到这里，JDK动态代理的原理就结束了。


CGLIB动态代理
CGLIB既可以代理接口，又可以代理类。底层采用继承的方式实现。所以被代理的目标类不能使用final修饰。
使用CGLIB，需要引入它的依赖：

和JDK动态代理原理差不多，在CGLIB中需要提供的不是InvocationHandler，而是：net.sf.cglib.proxy.MethodInterceptor
编写MethodInterceptor接口实现类：

● --add-opens java.base/java.lang=ALL-UNNAMED
● --add-opens java.base/sun.net.util=ALL-UNNAMED




